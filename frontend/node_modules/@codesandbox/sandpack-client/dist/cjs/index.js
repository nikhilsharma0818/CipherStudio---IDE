'use strict';

var templates = require('codesandbox-import-utils/lib/create-sandbox/templates');
var isEqual = require('lodash.isequal');

function _interopDefault (e) { return e && e.__esModule ? e : { default: e }; }

var isEqual__default = /*#__PURE__*/_interopDefault(isEqual);

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
}

/**
 * This file is a copy of the resolver from the `codesandbox-api` package.
 * We wanted to avoid to reference codesandbox-api because of the code that runs on load in the package.
 * The plan is to take some time and refactor codesandbox-api into what it was supposed to be in the first place,
 * an abstraction over the actions that can be dispatched between the bundler and the iframe.
 */
var Protocol = /** @class */ (function () {
    function Protocol(type, handleMessage, protocol) {
        var _this = this;
        this.type = type;
        this.handleMessage = handleMessage;
        this.protocol = protocol;
        this._disposeMessageListener = this.protocol.channelListen(function (msg) { return __awaiter(_this, void 0, void 0, function () {
            var message, result, response, err_1, response;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!(msg.type === this.getTypeId() && msg.method)) return [3 /*break*/, 4];
                        message = msg;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.handleMessage(message)];
                    case 2:
                        result = _a.sent();
                        response = {
                            type: this.getTypeId(),
                            msgId: message.msgId,
                            result: result
                        };
                        this.protocol.dispatch(response);
                        return [3 /*break*/, 4];
                    case 3:
                        err_1 = _a.sent();
                        response = {
                            type: this.getTypeId(),
                            msgId: message.msgId,
                            error: {
                                message: err_1.message
                            }
                        };
                        this.protocol.dispatch(response);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/];
                }
            });
        }); });
    }
    Protocol.prototype.getTypeId = function () {
        return "protocol-" + this.type;
    };
    Protocol.prototype.dispose = function () {
        this._disposeMessageListener();
    };
    return Protocol;
}());

var IFrameProtocol = /** @class */ (function () {
    function IFrameProtocol(iframe, origin) {
        // React to messages from any iframe
        this.globalListeners = {};
        this.globalListenersCount = 0;
        // React to messages from the iframe owned by this instance
        this.channelListeners = {};
        this.channelListenersCount = 0;
        // Random number to identify this instance of the client when messages are coming from multiple iframes
        this.channelId = Math.floor(Math.random() * 1000000);
        this.frameWindow = iframe.contentWindow;
        this.origin = origin;
        this.globalListeners = [];
        this.channelListeners = [];
        this.eventListener = this.eventListener.bind(this);
        if (typeof window !== "undefined") {
            window.addEventListener("message", this.eventListener);
        }
    }
    IFrameProtocol.prototype.cleanup = function () {
        window.removeEventListener("message", this.eventListener);
        this.globalListeners = {};
        this.channelListeners = {};
        this.globalListenersCount = 0;
        this.channelListenersCount = 0;
    };
    // Sends the channelId and triggers an iframeHandshake promise to resolve,
    // so the iframe can start listening for messages (based on the id)
    IFrameProtocol.prototype.register = function () {
        if (!this.frameWindow) {
            return;
        }
        this.frameWindow.postMessage({
            type: "register-frame",
            origin: document.location.origin,
            id: this.channelId
        }, this.origin);
    };
    // Messages are dispatched from the client directly to the instance iframe
    IFrameProtocol.prototype.dispatch = function (message) {
        if (!this.frameWindow) {
            return;
        }
        this.frameWindow.postMessage(__assign({ $id: this.channelId, codesandbox: true }, message), this.origin);
    };
    // Add a listener that is called on any message coming from an iframe in the page
    // This is needed for the `initialize` message which comes without a channelId
    IFrameProtocol.prototype.globalListen = function (listener) {
        var _this = this;
        if (typeof listener !== "function") {
            return function () {
                return;
            };
        }
        var listenerId = this.globalListenersCount;
        this.globalListeners[listenerId] = listener;
        this.globalListenersCount++;
        return function () {
            delete _this.globalListeners[listenerId];
        };
    };
    // Add a listener that is called on any message coming from an iframe with the instance channelId
    // All other messages (eg: from other iframes) are ignored
    IFrameProtocol.prototype.channelListen = function (listener) {
        var _this = this;
        if (typeof listener !== "function") {
            return function () {
                return;
            };
        }
        var listenerId = this.channelListenersCount;
        this.channelListeners[listenerId] = listener;
        this.channelListenersCount++;
        return function () {
            delete _this.channelListeners[listenerId];
        };
    };
    // Handles message windows coming from iframes
    IFrameProtocol.prototype.eventListener = function (evt) {
        // skip events originating from different iframes
        if (evt.source !== this.frameWindow) {
            return;
        }
        var message = evt.data;
        if (!message.codesandbox) {
            return;
        }
        Object.values(this.globalListeners).forEach(function (listener) {
            return listener(message);
        });
        if (message.$id !== this.channelId) {
            return;
        }
        Object.values(this.channelListeners).forEach(function (listener) {
            return listener(message);
        });
    };
    return IFrameProtocol;
}());

exports.SandpackLogLevel = void 0;
(function (SandpackLogLevel) {
    SandpackLogLevel[SandpackLogLevel["None"] = 0] = "None";
    SandpackLogLevel[SandpackLogLevel["Error"] = 10] = "Error";
    SandpackLogLevel[SandpackLogLevel["Warning"] = 20] = "Warning";
    SandpackLogLevel[SandpackLogLevel["Info"] = 30] = "Info";
    SandpackLogLevel[SandpackLogLevel["Debug"] = 40] = "Debug";
})(exports.SandpackLogLevel || (exports.SandpackLogLevel = {}));

var DEPENDENCY_ERROR_MESSAGE = "[sandpack-client]: \"dependencies\" was not specified - provide either a package.json or a \"dependencies\" value";
var ENTRY_ERROR_MESSAGE = "[sandpack-client]: \"entry\" was not specified - provide either a package.json with the \"main\" field or an \"entry\" value";
function createPackageJSON(dependencies, devDependencies, entry) {
    if (dependencies === void 0) { dependencies = {}; }
    if (devDependencies === void 0) { devDependencies = {}; }
    if (entry === void 0) { entry = "/index.js"; }
    return JSON.stringify({
        name: "sandpack-project",
        main: entry,
        dependencies: dependencies,
        devDependencies: devDependencies
    }, null, 2);
}
function addPackageJSONIfNeeded(files, dependencies, devDependencies, entry) {
    var _a, _b;
    var normalizedFilesPath = normalizePath(files);
    var packageJsonFile = normalizedFilesPath["/package.json"];
    /**
     * Create a new package json
     */
    if (!packageJsonFile) {
        if (!dependencies)
            throw new Error(DEPENDENCY_ERROR_MESSAGE);
        if (!entry)
            throw new Error(ENTRY_ERROR_MESSAGE);
        normalizedFilesPath["/package.json"] = {
            code: createPackageJSON(dependencies, devDependencies, entry)
        };
        return normalizedFilesPath;
    }
    /**
     * Merge package json with custom setup
     */
    if (packageJsonFile) {
        var packageJsonContent = JSON.parse(packageJsonFile.code);
        if (!dependencies && !packageJsonContent.dependencies) {
            throw new Error(DEPENDENCY_ERROR_MESSAGE);
        }
        if (dependencies) {
            packageJsonContent.dependencies = __assign(__assign({}, ((_a = packageJsonContent.dependencies) !== null && _a !== void 0 ? _a : {})), (dependencies !== null && dependencies !== void 0 ? dependencies : {}));
        }
        if (devDependencies) {
            packageJsonContent.devDependencies = __assign(__assign({}, ((_b = packageJsonContent.devDependencies) !== null && _b !== void 0 ? _b : {})), (devDependencies !== null && devDependencies !== void 0 ? devDependencies : {}));
        }
        if (entry) {
            packageJsonContent.main = entry;
        }
        normalizedFilesPath["/package.json"] = {
            code: JSON.stringify(packageJsonContent, null, 2)
        };
    }
    return normalizedFilesPath;
}
function extractErrorDetails(msg) {
    if (msg.title === "SyntaxError") {
        var title = msg.title, path = msg.path, message = msg.message, line = msg.line, column = msg.column;
        return { title: title, path: path, message: message, line: line, column: column };
    }
    var relevantStackFrame = getRelevantStackFrame(msg.payload.frames);
    if (!relevantStackFrame) {
        return { message: msg.message };
    }
    var errorInCode = getErrorInOriginalCode(relevantStackFrame);
    var errorLocation = getErrorLocation(relevantStackFrame);
    var errorMessage = formatErrorMessage(relevantStackFrame._originalFileName, msg.message, errorLocation, errorInCode);
    return {
        message: errorMessage,
        title: msg.title,
        path: relevantStackFrame._originalFileName,
        line: relevantStackFrame._originalLineNumber,
        column: relevantStackFrame._originalColumnNumber
    };
}
function getRelevantStackFrame(frames) {
    if (!frames) {
        return;
    }
    return frames.find(function (frame) { return !!frame._originalFileName; });
}
function getErrorLocation(errorFrame) {
    return errorFrame
        ? " (" + errorFrame._originalLineNumber + ":" + errorFrame._originalColumnNumber + ")"
        : "";
}
function getErrorInOriginalCode(errorFrame) {
    var lastScriptLine = errorFrame._originalScriptCode[errorFrame._originalScriptCode.length - 1];
    var numberOfLineNumberCharacters = lastScriptLine.lineNumber.toString().length;
    var leadingCharacterOffset = 2;
    var barSeparatorCharacterOffset = 3;
    var extraLineLeadingSpaces = leadingCharacterOffset +
        numberOfLineNumberCharacters +
        barSeparatorCharacterOffset +
        errorFrame._originalColumnNumber;
    return errorFrame._originalScriptCode.reduce(function (result, scriptLine) {
        var leadingChar = scriptLine.highlight ? ">" : " ";
        var lineNumber = scriptLine.lineNumber.toString().length === numberOfLineNumberCharacters
            ? "" + scriptLine.lineNumber
            : " " + scriptLine.lineNumber;
        var extraLine = scriptLine.highlight
            ? "\n" + " ".repeat(extraLineLeadingSpaces) + "^"
            : "";
        return (result + // accumulator
            "\n" +
            leadingChar + // > or " "
            " " +
            lineNumber + // line number on equal number of characters
            " | " +
            scriptLine.content + // code
            extraLine // line under the highlighed line to show the column index
        );
    }, "");
}
function formatErrorMessage(filePath, message, location, errorInCode) {
    return filePath + ": " + message + location + "\n" + errorInCode;
}
/* eslint-disable @typescript-eslint/no-explicit-any */
var normalizePath = function (path) {
    if (typeof path === "string") {
        return (path.startsWith("/") ? path : "/" + path);
    }
    if (Array.isArray(path)) {
        return path.map(function (p) { return (p.startsWith("/") ? p : "/" + p); });
    }
    if (typeof path === "object" && path !== null) {
        return Object.entries(path).reduce(function (acc, _a) {
            var key = _a[0], content = _a[1];
            var fileName = key.startsWith("/") ? key : "/" + key;
            acc[fileName] = content;
            return acc;
        }, {});
    }
    return null;
};

var _a;
var BUNDLER_URL = "https://" + ((_a = "1.20.9") === null || _a === void 0 ? void 0 : _a.replace(/\./g, "-")) + "-sandpack.codesandbox.io/";
var SandpackClient = /** @class */ (function () {
    function SandpackClient(selector, sandboxInfo, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        this.getTranspilerContext = function () {
            return new Promise(function (resolve) {
                var unsubscribe = _this.listen(function (message) {
                    if (message.type === "transpiler-context") {
                        resolve(message.data);
                        unsubscribe();
                    }
                });
                _this.dispatch({ type: "get-transpiler-context" });
            });
        };
        this.options = options;
        this.sandboxInfo = sandboxInfo;
        this.bundlerURL = options.bundlerURL || BUNDLER_URL;
        this.bundlerState = undefined;
        this.errors = [];
        this.status = "initializing";
        if (typeof selector === "string") {
            this.selector = selector;
            var element = document.querySelector(selector);
            if (!element) {
                throw new Error("[sandpack-client]: the element '" + selector + "' was not found");
            }
            this.element = element;
            this.iframe = document.createElement("iframe");
            this.initializeElement();
        }
        else {
            this.element = selector;
            this.iframe = selector;
        }
        if (!this.iframe.getAttribute("sandbox")) {
            this.iframe.setAttribute("sandbox", "allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts");
            this.iframe.setAttribute("allow", "accelerometer; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; clipboard-write;");
        }
        this.setLocationURLIntoIFrame();
        this.iframeProtocol = new IFrameProtocol(this.iframe, this.bundlerURL);
        this.unsubscribeGlobalListener = this.iframeProtocol.globalListen(function (mes) {
            if (mes.type !== "initialized" || !_this.iframe.contentWindow) {
                return;
            }
            _this.iframeProtocol.register();
            if (_this.options.fileResolver) {
                _this.fileResolverProtocol = new Protocol("fs", function (data) { return __awaiter(_this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        if (data.method === "isFile") {
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            return [2 /*return*/, this.options.fileResolver.isFile(data.params[0])];
                        }
                        else if (data.method === "readFile") {
                            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                            return [2 /*return*/, this.options.fileResolver.readFile(data.params[0])];
                        }
                        else {
                            throw new Error("Method not supported");
                        }
                    });
                }); }, _this.iframeProtocol);
            }
            _this.updatePreview(_this.sandboxInfo, true);
        });
        this.unsubscribeChannelListener = this.iframeProtocol.channelListen(function (mes) {
            switch (mes.type) {
                case "start": {
                    _this.errors = [];
                    break;
                }
                case "status": {
                    _this.status = mes.status;
                    break;
                }
                case "action": {
                    if (mes.action === "show-error") {
                        _this.errors = __spreadArray(__spreadArray([], _this.errors, true), [extractErrorDetails(mes)], false);
                    }
                    break;
                }
                case "state": {
                    _this.bundlerState = mes.state;
                    break;
                }
            }
        });
    }
    SandpackClient.prototype.setLocationURLIntoIFrame = function () {
        var _a;
        var urlSource = this.options.startRoute
            ? new URL(this.options.startRoute, this.bundlerURL).toString()
            : this.bundlerURL;
        (_a = this.iframe.contentWindow) === null || _a === void 0 ? void 0 : _a.location.replace(urlSource);
        this.iframe.src = urlSource;
    };
    SandpackClient.prototype.cleanup = function () {
        this.unsubscribeChannelListener();
        this.unsubscribeGlobalListener();
        this.iframeProtocol.cleanup();
    };
    SandpackClient.prototype.updateOptions = function (options) {
        if (!isEqual__default.default(this.options, options)) {
            this.options = options;
            this.updatePreview();
        }
    };
    SandpackClient.prototype.updatePreview = function (sandboxInfo, isInitializationCompile) {
        var _a, _b, _c, _d;
        if (sandboxInfo === void 0) { sandboxInfo = this.sandboxInfo; }
        this.sandboxInfo = __assign(__assign({}, this.sandboxInfo), sandboxInfo);
        var files = this.getFiles();
        var modules = Object.keys(files).reduce(function (prev, next) {
            var _a;
            return (__assign(__assign({}, prev), (_a = {}, _a[next] = {
                code: files[next].code,
                path: next
            }, _a)));
        }, {});
        var packageJSON = JSON.parse(createPackageJSON(this.sandboxInfo.dependencies, this.sandboxInfo.devDependencies, this.sandboxInfo.entry));
        try {
            packageJSON = JSON.parse(files["/package.json"].code);
        }
        catch (e) {
            console.error("[sandpack-client]: could not parse package.json file: " +
                e.message);
        }
        // TODO move this to a common format
        var normalizedModules = Object.keys(files).reduce(function (prev, next) {
            var _a;
            return (__assign(__assign({}, prev), (_a = {}, _a[next] = {
                content: files[next].code,
                path: next
            }, _a)));
        }, {});
        this.dispatch({
            type: "compile",
            codesandbox: true,
            version: 3,
            isInitializationCompile: isInitializationCompile,
            modules: modules,
            reactDevTools: this.options.reactDevTools,
            externalResources: this.options.externalResources || [],
            hasFileResolver: Boolean(this.options.fileResolver),
            disableDependencyPreprocessing: this.sandboxInfo.disableDependencyPreprocessing,
            template: this.sandboxInfo.template ||
                templates.getTemplate(packageJSON, normalizedModules),
            showOpenInCodeSandbox: (_a = this.options.showOpenInCodeSandbox) !== null && _a !== void 0 ? _a : true,
            showErrorScreen: (_b = this.options.showErrorScreen) !== null && _b !== void 0 ? _b : true,
            showLoadingScreen: (_c = this.options.showLoadingScreen) !== null && _c !== void 0 ? _c : true,
            skipEval: this.options.skipEval || false,
            clearConsoleDisabled: !this.options.clearConsoleOnFirstCompile,
            logLevel: (_d = this.options.logLevel) !== null && _d !== void 0 ? _d : exports.SandpackLogLevel.Info,
            customNpmRegistries: this.options.customNpmRegistries
        });
    };
    SandpackClient.prototype.dispatch = function (message) {
        /**
         * Intercept "refresh" dispatch: this will make sure
         * that the iframe is still in the location it's supposed to be.
         * External links inside the iframe will change the location and
         * prevent the user from navigating back.
         */
        if (message.type === "refresh") {
            this.setLocationURLIntoIFrame();
        }
        this.iframeProtocol.dispatch(message);
    };
    SandpackClient.prototype.listen = function (listener) {
        return this.iframeProtocol.channelListen(listener);
    };
    /**
     * Get the URL of the contents of the current sandbox
     */
    SandpackClient.prototype.getCodeSandboxURL = function () {
        var files = this.getFiles();
        var paramFiles = Object.keys(files).reduce(function (prev, next) {
            var _a;
            return (__assign(__assign({}, prev), (_a = {}, _a[next.replace("/", "")] = {
                content: files[next].code,
                isBinary: false
            }, _a)));
        }, {});
        return fetch("https://codesandbox.io/api/v1/sandboxes/define?json=1", {
            method: "POST",
            body: JSON.stringify({ files: paramFiles }),
            headers: {
                Accept: "application/json",
                "Content-Type": "application/json"
            }
        })
            .then(function (x) { return x.json(); })
            .then(function (res) { return ({
            sandboxId: res.sandbox_id,
            editorUrl: "https://codesandbox.io/s/" + res.sandbox_id,
            embedUrl: "https://codesandbox.io/embed/" + res.sandbox_id
        }); });
    };
    SandpackClient.prototype.getFiles = function () {
        var sandboxInfo = this.sandboxInfo;
        if (sandboxInfo.files["/package.json"] === undefined) {
            return addPackageJSONIfNeeded(sandboxInfo.files, sandboxInfo.dependencies, sandboxInfo.devDependencies, sandboxInfo.entry);
        }
        return this.sandboxInfo.files;
    };
    SandpackClient.prototype.initializeElement = function () {
        this.iframe.style.border = "0";
        this.iframe.style.width = this.options.width || "100%";
        this.iframe.style.height = this.options.height || "100%";
        this.iframe.style.overflow = "hidden";
        if (!this.element.parentNode) {
            // This should never happen
            throw new Error("[sandpack-client]: the given iframe does not have a parent.");
        }
        this.element.parentNode.replaceChild(this.iframe, this.element);
    };
    return SandpackClient;
}());

exports.SandpackClient = SandpackClient;
exports.addPackageJSONIfNeeded = addPackageJSONIfNeeded;
exports.createPackageJSON = createPackageJSON;
exports.extractErrorDetails = extractErrorDetails;
exports.normalizePath = normalizePath;
