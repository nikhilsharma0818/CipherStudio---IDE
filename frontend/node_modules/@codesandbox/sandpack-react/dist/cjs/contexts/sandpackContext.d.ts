/// <reference types="node" />
import type { ListenerFunction, SandpackMessage, UnsubscribeFunction, ReactDevToolsMode } from "@codesandbox/sandpack-client";
import { SandpackClient } from "@codesandbox/sandpack-client";
import * as React from "react";
import type { SandpackFiles } from "..";
import type { SandpackContext, SandpackInternalProvider, SandpackProviderState, SandpackProviderProps } from "../types";
/**
 * @category Provider
 */
declare const Sandpack: React.Context<SandpackContext | null>;
/**
 * Main context provider that should wraps your entire component.
 * Use * [`useSandpack`](/api/react/#usesandpack) hook, which gives you the entire context object to play with.
 *
 * @category Provider
 * @hidden
 */
export declare class SandpackProviderClass extends React.PureComponent<SandpackProviderProps, SandpackProviderState> {
    lazyAnchorRef: React.RefObject<HTMLDivElement>;
    preregisteredIframes: Record<string, HTMLIFrameElement>;
    clients: Record<string, SandpackClient>;
    errorScreenRegistered: React.MutableRefObject<boolean>;
    openInCSBRegistered: React.MutableRefObject<boolean>;
    loadingScreenRegistered: React.MutableRefObject<boolean>;
    intersectionObserver?: IntersectionObserver;
    queuedListeners: Record<string, Record<string, ListenerFunction>>;
    unsubscribeClientListeners: Record<string, Record<string, UnsubscribeFunction>>;
    unsubscribe?: UnsubscribeFunction;
    debounceHook?: number;
    timeoutHook: NodeJS.Timer | null;
    initializeSandpackIframeHook: NodeJS.Timer | null;
    constructor(props: SandpackProviderProps);
    handleMessage: (msg: SandpackMessage) => void;
    registerReactDevTools: (value: ReactDevToolsMode) => void;
    updateCurrentFile: (code: string) => void;
    updateFile: (pathOrFiles: string | SandpackFiles, code?: string | undefined) => void;
    updateClients: () => void;
    initializeSandpackIframe(): void;
    componentDidMount(): void;
    componentDidUpdate(prevProps: SandpackProviderProps): void;
    componentWillUnmount(): void;
    createClient: (iframe: HTMLIFrameElement, clientId: string) => SandpackClient;
    runSandpack: () => void;
    registerBundler: (iframe: HTMLIFrameElement, clientId: string) => void;
    unregisterBundler: (clientId: string) => void;
    unregisterAllClients: () => void;
    setActiveFile: (activeFile: string) => void;
    openFile: (path: string) => void;
    closeFile: (path: string) => void;
    deleteFile: (path: string) => void;
    addFile: (pathOrFiles: string | SandpackFiles, code?: string | undefined) => void;
    dispatchMessage: (message: SandpackMessage, clientId?: string | undefined) => void;
    addListener: (listener: ListenerFunction, clientId?: string | undefined) => UnsubscribeFunction;
    resetFile: (path: string) => void;
    resetAllFiles: () => void;
    _getSandpackState: () => SandpackContext;
    render(): React.ReactElement;
}
/**
 * @hidden
 */
declare const SandpackProvider: SandpackInternalProvider;
/**
 * @category Provider
 */
declare const SandpackConsumer: React.Consumer<SandpackContext | null>;
export { SandpackProvider, SandpackConsumer, Sandpack as SandpackReactContext };
